/*
 * File generated by Octopus Code Generator on Dec 29, 2006 11:21:31 AM
 */
package org.opaeum.java.metamodel.generated;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.opaeum.java.metamodel.OJBlock;
import org.opaeum.java.metamodel.OJClassifier;
import org.opaeum.java.metamodel.OJOperation;
import org.opaeum.java.metamodel.OJParameter;
import org.opaeum.java.metamodel.OJPathName;
import org.opaeum.java.metamodel.OJVisibleElement;
import org.opaeum.java.metamodel.utilities.InvariantError;

/**
 * Class ...
 */
abstract public class OJOperationGEN extends OJVisibleElement {
	private boolean f_isAbstract = false;
	private boolean f_needsSuppress = false;
	private OJPathName f_genericTypeParam = null;
	private List<OJParameter> f_parameters = new ArrayList<OJParameter>();
	private OJBlock f_body = null;
	private OJClassifier f_owner = null;
	private OJPathName f_returnType = null;
	private Set<OJPathName> f_throws = new HashSet<OJPathName>();
	static protected boolean usesAllInstances = false;
	static protected List<OJOperation> allInstances = new ArrayList<OJOperation>();

	/**
	 * Constructor for OJOperationGEN
	 * 
	 * @param name
	 * @param comment
	 * @param isStatic
	 * @param isFinal
	 * @param isVolatile
	 * @param isAbstract
	 * @param needsSuppress
	 */
	protected OJOperationGEN(String name, String comment, boolean isStatic, boolean isFinal, boolean isVolatile, boolean isAbstract, boolean needsSuppress) {
		super();
		super.setName(name);
		super.setComment(comment);
		super.setStatic(isStatic);
		super.setFinal(isFinal);
		super.setVolatile(isVolatile);
		this.setAbstract(isAbstract);
		this.setNeedsSuppress(needsSuppress);
		this.setReturnType(OJPathName.getVOID());
		if (usesAllInstances) {
			allInstances.add(((OJOperation) this));
		}
	}

	/**
	 * Default constructor for OJOperation
	 */
	protected OJOperationGEN() {
		super();
		this.setReturnType(OJPathName.getVOID());
		if (usesAllInstances) {
			allInstances.add(((OJOperation) this));
		}
	}

	/**
	 * Implements the user defined operation '+ getParamTypes() :
	 * Sequence(OJPathName)'
	 */
	public List<OJPathName> getParamTypes() {
		List<OJPathName> result = new ArrayList<OJPathName>();
		return result;
	}

	/**
	 * Implements the user defined operation '+ isEqual( name: String, types:
	 * Sequence(OJPathName) ) : Boolean'
	 * 
	 * @param name
	 * @param types
	 */
	public boolean isEqual(String name, List<OJPathName> types) {
		return (this.getName().equals(name) && (forAll2(name, types)));
	}

	/**
	 * Implements the getter for attribute '+ isAbstract : Boolean'
	 */
	public boolean isAbstract() {
		return f_isAbstract;
	}

	/**
	 * Implements the setter for attribute '+ isAbstract : Boolean'
	 * 
	 * @param element
	 */
	public void setAbstract(boolean element) {
		if (f_isAbstract != element) {
			f_isAbstract = element;
		}
	}

	/**
	 * Implements the getter for attribute '+ needsSuppress : Boolean'
	 */
	public boolean getNeedsSuppress() {
		return f_needsSuppress;
	}

	/**
	 * Implements the setter for attribute '+ needsSuppress : Boolean'
	 * 
	 * @param element
	 */
	public void setNeedsSuppress(boolean element) {
		if (f_needsSuppress != element) {
			f_needsSuppress = element;
		}
	}

	/**
	 * Implements the getter for attribute '+ genericTypeParam : OJPathName'
	 */
	public OJPathName getGenericTypeParam() {
		return f_genericTypeParam;
	}

	/**
	 * Implements the setter for attribute '+ genericTypeParam : OJPathName'
	 * 
	 * @param element
	 */
	public void setGenericTypeParam(OJPathName element) {
		if (f_genericTypeParam != element) {
			f_genericTypeParam = element;
		}
	}

	/**
	 * Implements the getter for association end '+ parameters :
	 * OrderedSet(OJParameter)'
	 */
	public List<OJParameter> getParameters() {
		return f_parameters;
	}

	/**
	 * Implements the setter for association end '+ parameters :
	 * OrderedSet(OJParameter)'
	 * 
	 * @param element
	 */
	public void setParameters(List<OJParameter> element) {
		if (f_parameters != element) {
			f_parameters = element;
		}
	}

	/**
	 * Implements the add element function for association end '+ parameters :
	 * OrderedSet(OJParameter)'
	 * 
	 * @param element
	 */
	public void addToParameters(OJParameter element) {
		if (f_parameters.contains(element)) {
			return;
		}
		f_parameters.add(element);
	}

	/**
	 * Implements the remove element function for association end '+ parameters
	 * : OrderedSet(OJParameter)'
	 * 
	 * @param element
	 */
	public void removeFromParameters(OJParameter element) {
		f_parameters.remove(element);
	}

	/**
	 * Implements the addition of a number of elements to association end '+
	 * parameters : OrderedSet(OJParameter)'
	 * 
	 * @param newElems
	 */
	public void addToParameters(Collection<OJParameter> newElems) {
		for (OJParameter item : newElems) {
			addToParameters(item);
		}
	}

	/**
	 * Implements the removal of a number of elements from association end '+
	 * parameters : OrderedSet(OJParameter)'
	 * 
	 * @param oldElems
	 */
	public void removeFromParameters(Collection<OJParameter> oldElems) {
		for (OJParameter item : oldElems) {
			removeFromParameters(item);
		}
	}

	/**
	 * Implements the removal of all elements from association end '+ parameters
	 * : OrderedSet(OJParameter)'
	 */
	public void removeAllFromParameters() {
		/*
		 * make a copy of the collection in order to avoid a
		 * ConcurrentModificationException
		 */
		for (OJParameter item : new ArrayList<OJParameter>(getParameters())) {
			removeFromParameters(item);
		}
	}

	/**
	 * Implements the getter for association end '+ body : OJBlock'
	 */
	public OJBlock getBody() {
		return f_body;
	}

	/**
	 * Implements the setter for association end '+ body : OJBlock'
	 * 
	 * @param element
	 */
	public void setBody(OJBlock element) {
		if (f_body != element) {
			f_body = element;
		}
	}

	/**
	 * Implements the setter of association end '+ owner : OJClassifier'
	 * 
	 * @param element
	 */
	public void setOwner(OJClassifier element) {
		if (this.f_owner != element) {
			if (this.f_owner != null) {
				this.f_owner.z_internalRemoveFromOperations(((OJOperation) this));
			}
			this.f_owner = element;
			if (element != null) {
				element.z_internalAddToOperations(((OJOperation) this));
			}
		}
	}

	/**
	 * Implements the getter for association end '+ owner : OJClassifier'
	 */
	public OJClassifier getOwner() {
		return f_owner;
	}

	/**
	 * Should NOT be used by clients! Implements the correct setting of the link
	 * for association end '+ owner : OJClassifier' when a single element is
	 * added to it.
	 * 
	 * @param element
	 */
	public void z_internalAddToOwner(OJClassifier element) {
		this.f_owner = element;
	}

	/**
	 * Should NOT be used by clients! Implements the correct setting of the link
	 * for association end '+ owner : OJClassifier' when a single element is
	 * removed to it.
	 * 
	 * @param element
	 */
	public void z_internalRemoveFromOwner(OJClassifier element) {
		this.f_owner = null;
	}

	/**
	 * Implements the getter for association end '+ returnType : OJPathName'
	 */
	public OJPathName getReturnType() {
		return f_returnType;
	}

	/**
	 * Implements the setter for association end '+ returnType : OJPathName'
	 * 
	 * @param element
	 */
	public void setReturnType(String element) {
		setReturnType(new OJPathName(element));
	}

	/**
	 * Implements the setter for association end '+ returnType : OJPathName'
	 * 
	 * @param element
	 */
	public void setReturnType(OJPathName element) {
		if (f_returnType != element) {
			f_returnType = element;
		}
	}

	/**
	 * Implements the getter for association end '+ throws : Set(OJPathName)'
	 */
	public Set<OJPathName> getThrows() {
		return f_throws;
	}

	/**
	 * Implements the setter for association end '+ throws : Set(OJPathName)'
	 * 
	 * @param element
	 */
	public void setThrows(Set<OJPathName> element) {
		if (f_throws != element) {
			f_throws = element;
		}
	}

	/**
	 * Implements the add element function for association end '+ throws :
	 * Set(OJPathName)'
	 * 
	 * @param element
	 */
	public void addToThrows(OJPathName element) {
		if (f_throws.contains(element)) {
			return;
		}
		f_throws.add(element);
	}

	/**
	 * Implements the remove element function for association end '+ throws :
	 * Set(OJPathName)'
	 * 
	 * @param element
	 */
	public void removeFromThrows(OJPathName element) {
		f_throws.remove(element);
	}

	/**
	 * Implements the addition of a number of elements to association end '+
	 * throws : Set(OJPathName)'
	 * 
	 * @param newElems
	 */
	public void addToThrows(Collection<OJPathName> newElems) {
		for (OJPathName item : newElems) {
			addToThrows(item);
		}
	}

	/**
	 * Implements the removal of a number of elements from association end '+
	 * throws : Set(OJPathName)'
	 * 
	 * @param oldElems
	 */
	public void removeFromThrows(Collection<OJPathName> oldElems) {
		for (OJPathName item : oldElems) {
			removeFromThrows(item);
		}
	}

	/**
	 * Implements the removal of all elements from association end '+ throws :
	 * Set(OJPathName)'
	 */
	public void removeAllFromThrows() {
		/*
		 * make a copy of the collection in order to avoid a
		 * ConcurrentModificationException
		 */
		for (OJPathName item : new HashSet<OJPathName>(getThrows())) {
			removeFromThrows(item);
		}
	}

	/**
	 * Implements OrderedSet{1 .. self.parameters->size()}
	 * 
	 * @param name
	 * @param types
	 */
	private List<Integer> collectionLiteral1(String name, List<OJPathName> types) {
		List<Integer> myList = new ArrayList<Integer>();
		for (int i = 1; i <= this.getParameters().size(); i++)
			myList.add(new Integer(i));
		return myList;
	}

	/**
	 * Implements ->forAll( i : Integer |
	 * self.parameters->at(i).type.equals(types->at(i)) )
	 * 
	 * @param name
	 * @param types
	 */
	private boolean forAll2(String name, List<OJPathName> types) {
		Iterator it = collectionLiteral1(name, types).iterator();
		while (it.hasNext()) {
			Integer i = (Integer) it.next();
			if (!(this.getParameters().size() > i.intValue() - 1 ? ((OJParameter) this.getParameters().get(i.intValue() - 1)) : null).getType().equals(
					(types.size() > i.intValue() - 1 ? ((OJPathName) types.get(i.intValue() - 1)) : null))) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Checks all invariants of this object and returns a list of messages about
	 * broken invariants
	 */
	public List<InvariantError> checkAllInvariants() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		return result;
	}

	/**
	 * Implements a check on the multiplicities of all attributes and
	 * association ends
	 */
	public List<InvariantError> checkMultiplicities() {
		List<InvariantError> result = new ArrayList<InvariantError>();
		if (getOwner() == null) {
			String message = "Mandatory feature 'owner' in object '";
			message = message + this.getIdString();
			message = message + "' of type '" + this.getClass().getName() + "' has no value.";
			result.add(new InvariantError(((OJOperation) this), message));
		}
		if (getReturnType() == null) {
			String message = "Mandatory feature 'returnType' in object '";
			message = message + this.getIdString();
			message = message + "' of type '" + this.getClass().getName() + "' has no value.";
			result.add(new InvariantError(((OJOperation) this), message));
		}
		return result;
	}

	/**
	 * Returns the default identifier for OJOperation
	 */
	public String getIdString() {
		String result = "";
		result = super.getIdString();
		return result;
	}

	/**
	 * Implements the OCL allInstances operation
	 */
	static public List allInstances() {
		if (!usesAllInstances) {
			throw new RuntimeException(
					"allInstances is not implemented for ((OJOperation)this) class. Set usesAllInstances to true, if you want allInstances() implemented.");
		}
		return allInstances;
	}

}